<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[浅谈TCP端口扫描技术]]></title>
      <url>%2F2017%2F05%2F04%2F%E6%B5%85%E8%B0%88TCP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[端口扫描描述在一般的网络攻击或者说渗透测试中，首要任务也是最重要的任务就是踩点，也就是对目标系统信息的收集，而端口扫描就是踩点中最重要的一项。端口扫描不仅用于踩点，并且经常用于批量抓取肉鸡，就是在扫描到端口开放后就用弱口令尝试登录系统，最后将这些肉鸡用于 ddos 等其它领域。互联网中常用的端口有 ftp 服务端口 21 ，ssh 服务端口 22 ，TELNET 远程登录服务 23 ，DNS 服务端口 53 ，http 服务端口 80，windous 远程桌面服务 3389 端口，SQL Server 服务端口 1433 ，mysql 端口 3306 。在网络中，你的系统开放了几个端口，也就意味着你为别人开了几扇门,所以网络攻击是离不开端口的，黑客利用这些开放的端口就能进入你的系统，所以一个系统开放越少的端口就越安全。我们在计算机网络课程中都学过，端口这个概念来自于OSI模型中的传输层，用于系统中各个应用程序与外界交流。而传输层有TCP和UDP协议，所以端口也就分为TCP端口和UDP端口，现在我着重讲解的是TCP端口扫描。 TCP 端口扫描技术TCP 端口扫描技术的基础是 TCP 协议中的三次握手以及四次挥手，这里面就涉及了 TCP 首头中的几个控制位，URG，ACK，PSH，RST，SYN，FIN。一次完整的 TCP 连接的步骤： 客户端发起连接将数据报中将 TCP 首头的 SYN 控制位置为 1，表明这是一个连接请求 。 服务端接受到连接请求，如果这个端口是开放的，就将回复的数据报 TCP 首头中 SYN 置为1，ACK 位也置位 1，表明接受请求并且也请求连接。如果这个端口没有开放，就将 RST 位置为1，表明这个连接失败。 客户端接受到服务器的回复，如果 SYN 和 ACK 位为1，就将 RST 位和 ACK 位置为 1 ，表明接受请求并且连接完毕。如果 RST 位为1，说明连接失败。 而每种 TCP 端口扫描技术都是在这上面动手脚。 TCP 全连接全 TCP 连接是 TCP 端口扫描的基础。它是我们最熟悉的，我们经常写的网络程序都会用到，它的原理很简单，就是一个普通的完整的 sockt 连接，也就是完整的三次握手和四次挥手。如果连接成功就说明这个端口是开放的，反之则是关闭的。虽然这种扫描技术简单且容易实现并且无需任何特殊权限，但是这种扫描容易被检测出来并且很慢，所以很不安全，用的很少。 SYN 扫描SYN 扫描也被称为半开放扫描，它和 TCP 全连接差不多，只是如果端口开放，在第三次握手的时候只将 RST 位置为 1 。直接就将连接断开了，这样就可以绕开很多防火墙，检测出来的几率大大减小，就安全很多并且比较准确，所以这种方式用的比较多。 FIN 扫描FIN 扫描又称隐藏连接，它和前两种有比较大的区别，因为前两种都是在建立连接是操作的，而这种扫描方式是基于断开连接的。它将 TCP 首头中 FIN 控制位置为 1 ，请求与服务器断开连接，如果服务器上这个端口关闭时，服务器会返回一个报文，并且 RST 位置为 1 。如果这个端口开放，因为并没有建立连接，何谈断开连接，所以服务器不会返回任何报文。而如果服务器返回一个 IMCP 报文，则表示这个报文被防火墙过滤了，所以这种方式很准确且速度比前两种快得多。 常见的端口扫描器 Nmap:Nmap 是一款用于网络发现和安全审计的网络安全工具，支持十几种端口扫描技术，当然它不仅用于端口扫描，它的功能很强大，基本是网络攻击的必备工具。 Zmap:Zmap 是一款号称一个小时扫完全网的端口扫描器，它采用的是一种加强的 SYN 扫描技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven将java项目打包成可独立运行的jar包]]></title>
      <url>%2F2017%2F04%2F04%2FMaven%E5%B0%86java%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E7%8B%AC%E7%AB%8B%E8%BF%90%E8%A1%8C%E7%9A%84jar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[在java项目中，常常需要打包成独立jar包方便发送或者发放。而maven默认的打包插件并没有在项目清单MANIFEST.MF中添加主类和依赖信息，所以运行时就会出错。所以我们需要使用其它的插件来打包。 方法一 使用maven-assembly-plugin插件123456789101112131415161718192021222324252627282930&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 方法二 使用maven-shade-plugin插件1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果使用了Spring，Spring Framework的多个jar包中包含相同的文件spring.handlers和spring.schemas，如果生成一个jar包会互相覆盖。为了避免互相影响，可以使用AppendingTransformer来对文件内容追加合并1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 引用 http://blog.csdn.net/daiyutage/article/details/53739452]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式学习（续）]]></title>
      <url>%2F2017%2F03%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BB%AD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[适配器模式 将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 外观模式 提供一个统一的接口用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts 2 复习]]></title>
      <url>%2F2017%2F03%2F21%2F2017-3-21-Struts-2-%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Struts 2 简介Apache Struts 2是一个用于开发Java EE网络应用程序的开源框架。它利用并延伸了Java Servlet API，鼓励开发者采用MVC架构。Struts 2 与Struts 1 有很大的不同，它缘起于Apache的WebWork框架，旨在提供相对于Struts1框架的增强和改进，同时保留与Struts1框架类似的结构。但实质是以WebWork为核心。2005年12月，WebWork宣布WebWork 2.2以Apache Struts 2的名义合并至Struts。 Struts 2 原理Struts 2 结构图: Struts 2 流程图: Struts 2 处理步骤: 客户端发生一个请求（HttpServletRequest）； 请求被Struts 2 中定义的三层过滤器（Filter）如：ActionCOntextCleanUp、SiteMesh、FilterDispatcher； FilterDisPatcher做为Struts 2 的控制器核心，询问ActionMapper是否需要调用某个Action来处理这个请求，如果决定调用,FilterDispatcher则把请求交给ActionProxy； ActionProxy通过Configuration Manager查询配置文件（struts.xml），找到需要调用的Action类。 ActionProxy 创建一个ActionInvocation 的实例，同时ActionInvocation 通过代理模式调用Action。但在调用之前会根据配置文件加载所有与Action 相关的Interceptor； 当Action 执行完毕后，ActionInvocation 负责根据配置文件找到相应的返回结果（struts.xml中action节点的result节点）并执行相关动作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式学习]]></title>
      <url>%2F2017%2F03%2F14%2F2017-3-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[OO基础 抽象 封装 多态 继承 OO原则 封装变化的 多用组合，少用继承 针对接口编程，不针对实现编程 低耦合，高内聚 对扩展开放，对修改关闭 OO模式模式是历经验证的OO设计经验 策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。（例子：鸭子飞的行为与叫的行为） 观察者模式 观察者模式定义了对象之间的一对多依赖，当一个对象(主题)改变状态时，它的所有依赖者(观察者)都会收到通知并自动更新。(例子：报社与订阅者之间的关系） 装饰者模式 动态的将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。java库中IO类如FileInputStream(new InputStream())采用此模式。(例子：饮料添加各种调料） 工厂方法模式 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。(各个地方开披萨分店，但各个地方口味不同） 单例模式 单例模式就是一个类只能生成一个对象。分为懒汉式（用时生成对象）和饿汉式（类加载时就生成对象），懒汉式线程不安全，饿汉式线程安全。懒汉式可以将获得对象的静态方法变成同步方法（加synchronized关键字）使之成为线程安全。当然这种方式性能不太好，另一种方式是“双重检查加锁”，在判断对象是否生成后再同步。1234567if(instance == null)&#123; synchronized (Singleton.class) &#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python编码详解]]></title>
      <url>%2F2017%2F02%2F27%2F2017-2-27-python%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[概念编码（Encode） 用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。也就是将文字等信息以二进制数据存储到计算机中。与之相对应的就是解码（Decode）。 问题由来在计算机中，经常会遇到乱码，莫名其妙就是一堆看不懂的东西。现在我主要要两个地方经常遇到乱码，一个是网站网页中，经常写的网页中文就是乱码，这个还好解决一点。第二个就是在python编程中，经常会遇到莫名错误提示，代表性的：&lt; UnicodeDecodeError:’ascii’ codec can’t decode byte 0xe5 in position 0有时候搞半天不知道哪儿出错了，就卡在那儿不知所措。要想解决这些问题，我们就必须把计算机中编码解码问题搞清楚。 编码历史#ASCII1946年2月14日第一台计算机在每个宾夕法尼亚大学诞生，为了在计算机中表示英语，美国人就制定了一套标准，这就是ASCII。它用一个字节来表示英文中所有字符和一些常用字符(键盘上每一个键位)，一个字节（8位）可以表示256个字符，表示英文中那几个字符绰绰有余。并且刚开始只用了7位，最高位保留为0。后来计算机普及到西欧地区时才将最高位用到，制定了EASCII（Extesible ASCII）标准。 #GB2312和GBK20世纪八十年代左右，计算机开始普及到中国，但这时就面临着一个问题，那就是汉字成千上万，这已经不是ASCII所能表示的范围了。为了解决这个问题，1981年中国国家标准总局发布了GB2312编码标准。它基本能表示99.75%的汉字。但随着各方面的需求，这也不能满足。于是又在GB2312的基础上又创建了GBK编码。它不仅能表示27484个汉字。还可以表示很多少数民族的文字。 #Unicode就这样，全世界各国都发布了自己的标准。在互联网上交流和传输数据就会出现问题。于是为了统一世界的文字编码。统一国际组织提出了Unicode编码。普遍所用的Unicode用4个字节来表示字符，最高位仍保留为0，这完全能囊括世界所有的文字字符，世界上任何一个字符都可以用一个Unicode编码来表示，一旦字符的Unicode编码确定下来后，就不会再改变了。 #UTF-8Unicode的实现方式不同于编码方式。在实际传输与保存时，由于不同的系统平台设计不一定，或者为了节省存储空间，必定用4个字节来保存一个字符太浪费空间了。于是Unicode就有了不同的实现方式，如UTF-16，UTF-8等，当然用的多的就是UTF-8了。 UTF-8（Unicode Transformation Format）作为Unicode的一种实现方式，广泛应用于互联网，它是一种变长的字符编码，可以根据具体情况用1-4个字节来表示一个字符。比如英文字符这些原本就可以用ASCII码表示的字符用UTF-8表示时就只需要一个字节的空间，和ASCII是一样的。对于多字节（n个字节）的字符，第一个字节的前n为都设为1，第n+1位设为0，后面字节的前两位都设为10。剩下的二进制位全部用该字符的unicode码填充。以汉字“好”为例，“好”对应的Unicode是597D，对应的区间是0000 0800–0000 FFFF，因此它用UTF-8表示时需要用3个字节来存储，597D用二进制表示是： 0101100101111101，填充到1110xxxx 10xxxxxx 10xxxxxx得到11100101 10100101 10111101，转换成16进制：e5a5bd，因此“好”的Unicode”597D”对应的UTF-8编码是”E5A5BD” #Python字符编码问题由于Python出的比Uncode早，所以python用的编码就是ASICC，源代码也必须是ASCII，所以在源码中不能有汉字，为了在源码中支持中文，就必须在在源文件开头指定编码格式。 #coding=utf-8或者-- coding: utf-8 __在python中字符串有两种数据类型str和unicode。str类型的字符具体编码和操作系统有关。 python中str与unicode之间的转换也是decode和encode： str–&gt;unicode 用decode方法。unicode–&gt;str 用encode方法。 #参考 https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;mid=2652564196&amp;idx=2&amp;sn=f12b49f57d22309fe84e6c2518e99de5&amp;pass_ticket=15P%2BhK91bYNpbTZ4iSMRdhysUWU%2BrOfaA0lJ5ydo4%2FfGVjyXErn4ZN70qKCqwPf%2B http://www.liaoxuefengcom/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始！]]></title>
      <url>%2F2017%2F02%2F08%2F2017-2-8-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%EF%BC%81%2F</url>
      <content type="text"><![CDATA[前期总结眨眼间，大三已去一半，回顾大学两年半,基本都在各种论坛闲逛，基本没怎么发言，都是潜水。 或者折腾各种软件，杂七杂八的东西。虽然也学到了不少东西，但是我总觉得缺少了很多东西，在实际操作中总是会遇到很多问题。特别是上学期，我严重发现了自己的不足。也有过一次短期培训，让我稍微清楚了实际项目的流程。 经过自己的总结，我得出以下一些问题。 学的太多太杂，不深入。 自己学得模式有点像猴子搬包谷，看到听到什么就想去学什么。 实际操作太少，基本就是看了一些文章。 自己也有点太过自(zi)信(da)，总认为已经够了。 后期展望大三上期就像一个过渡期，让我看到了以前得不足，让我明白了很多东西。也让我对未来有了一定得规划,准备。争取在大学接下来的日子尽量充实自己，找一个好的工作，在计算机这条道路上走的更远。 确定未来方向，主要专研java，python方面，当然这里面也包括了很多东西，尽量都深入一下。 多找一些实际项目来做，尽量多操作，多实践，弥补这方面的不足。 最后最后说一下本博客得开通吧！首先感谢一下hexo和github以及next，让我们写博客更方便，快捷，开源大法好。 由于一个新的开始嘛，我就想着现在开始写博客。一来提高自己得写作以及表达能力；二来总结一下自己所学的知识，所谓好记性不如烂笔头嘛；三来和各位分享一下自己的心得，当然能得到大家的评鉴就更好了，一起提高嘛！！。 开始起航吧,加油！！！！]]></content>
    </entry>

    
  
  
</search>
