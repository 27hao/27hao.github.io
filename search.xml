<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaEE中servlet，filter，listener解析]]></title>
      <url>%2F2017%2F07%2F24%2FJavaEE%E4%B8%ADservlet%EF%BC%8Cfilter%EF%BC%8Clistener%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[web.xml 的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servlet ，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。 Filter它使用户可以改变一个 request和修改一个response. Filter 不是一个servlet,它不能产生一个response,它能够在一个request到达servlet之前预处理request,也可以在离开 servlet时处理response.换种说法,filter其实是一个”servlet chaining”(servlet 链).我们可以利用它来转换编码，权限验证等功能。 在 servlet 之前调用； 在 servlet 调用之前检查 request; 根据需要修改 request 和 response; 在 servlet 调用之后截获，继续修改相应数据; 在实现 filter 中 doFilter 方法时必须调用 chain.doFilter(req,resp) 表示调用下一个 filter 或者最终请求。 ServletServlet是使用Java Servlet 应用程序设计接口（API）及相关类和方法的 Java 程序。除了 java Servlet API，Servlet 还可以使用用以扩展和添加到 API 的 Java 类软件包。Servlet 在启用 Java 的 Web 服务器上或应用服务器上运行并扩展了该服务器的能力。Java servlet对于Web服务器就好象Java applet对于Web浏览器。Servlet装入Web服务器并在Web服务器内执行，而applet装入Web浏览器并在Web浏览器内执行。Java Servlet API 定义了一个servlet 和Java使能的服务器之间的一个标准接口，这使得Servlets具有跨服务器平台的特性。 它的拦截规则当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下： 精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。 最长路径匹配。例子：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：*.action 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet Listener它是基于观察者模式设计的。目前 Servlet 中提供了 5 种两类事件的观察者接口，我们实现它们，然后在 web.xml 里配置好就可以使用监听器了，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。作为 Servlet 的监听器，它可以监听客户端的请求，服务端的操作等。比如监听在线用户数量：当增加一个 session 时，就触发 sessionCreated 方法，将人数加 1。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL 语句的优化]]></title>
      <url>%2F2017%2F06%2F19%2FSQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[大批量插入数据 对于 MyISAM 储存引擎，可以用以下方式快速导入大量数据到一个非空表： alter table tab_name disable keys;load data infile ‘data.txt’ into table tab_name;alter table tab_name enable keys; 上述设置只对 MyISAM有用，对 InnoDB 表无用，因为 InnoDB 表是按主键顺序保存的，如果数据按照主键顺序排序，可以有效提高导入数据。 在导入前关闭唯一性校验，导入后再恢复，可以提高效率； set unique_checks=0load data infile ‘data.txt’ into table tab_nameset unique_checks=1 如果使用自动提交的方式，建议先关闭自动提交，导入后再打开，也可以提交效率； set autocommit=0 优化 insert 语句 如果同时从同一客户端插入多行，应用多个值表的 insert 语句，减少客户端与数据库之间的连接，关闭等消耗； 如果从不同客户端同时插入多行，可以通过 insert delayed 语句得到更高的速度，它让 insert 马上执行，只是先放到内存队列中，再慢慢写入磁盘； 将索引文件和数据文件分在不同的磁盘上存放； 如果进行批量插入，可以提高 bulk_insert_buffer_size 的值（只对 MyISAM 表使用）； 从一个文本载入数据时，load 比 insert 大约快 20 倍。 优化分页查询一般分页查询时，都会用到“limit 1000,20”类似的语句，但这样 Mysql 是读取 1020 条记录，然后再返回最后 20 条，这样就耗时太大； 在索引上完成排序分页操作，最后根据主键关联会原表要查询的列； select film_id, description from film order by title limit 50,5;SELECT a.film_id, a.description from film a inner join (select film_id from film ORDER BY title limit 50,5)b on a.film_id=b.film_id; 常用 SQL 技巧 运用正则表达式 select * from table where col reqexp ‘exp’; 用 rand() 提取随机行 select * from table order by rand() limit n; 利用 group by 的 with rollup 字句可以查询出分组的聚合信息 select col1,col2,sum(col3) from table group by col1;select col1,col2,sum(col3) from table group by col1 with rollup;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql 优化]]></title>
      <url>%2F2017%2F06%2F16%2FMysql-%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[当面对一个 SQL 性能问题时，我们应该从何处找到问题，哪里用的时间过多，我们才能着手优化。 查看本次连接信息: status 查看服务器提供的状态信息: show [session|global] status Com_select:执行 select 操作的次数，一次查询值累加 1； Com_Insert:执行 insert 操作的次数； Com_update:执行 update 的次数； Com_delete:执行 delete 的次数； Innodb_rows_read:执行 select 查询返回的行数； Innodb_rows_inserted:执行 insert 操作插入的行数; Innodb_rows_updated:执行 update 操作更新的行数； Innodb_rows_deleted:执行 delete操作删除的行数； Com_commit:事务提交次数； Com_rollback:事务回滚的次数； Handler_read_key:表明系统正在使用索引，越高越好； Handler_read_next:使用索引读取数据的次数； Handler_read_rnd_next:表示在数据文件读取数据的次数，如果值很大，说明应该使用索引。 通过上述参数的值我们可以很容易的了解当前数据库是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致执行比例是多少。对于更新操作的计数，是对执行次数的计数，无论是提交还是回滚都会计数。如果回滚非常频繁，意味着应用编写可能存在问题。 通过 EXPLAIN 分析 SQL 语句的执行计划 explain sql语句\G select_type: 表示 select 的类型，常见取值有 SIMPLE（简单表，没有使用表连接或子查询），PRIMARY（主查询），UNION（UNION 中的第二个或者后面的查询语句），SUBQUERY（子查询中的第一个 SELECT）等。 type:表示 Mysql 在表中查询的方式，或者叫访问类型。ALL（全表扫描），index（索引全扫描，遍历整个索引），range（索引范围扫描，常见于比较符 &lt; &gt;等），ref（索引的前缀扫描，返回匹配某个单独值的记录），const/system（表中最多只有一个匹配行，根据主键或唯一索引查询时），速度依次变快。 possible_keys:表示查询时可能用到的索引； key:表示实际用的索引； key_len:使用到索引字段的长度； rows:总共扫描了多少行； 通过 show profile 分析 SQL 执行详细时间 select @@having_profiling; 查看是否支持 profileset profiling=1; 开启 profile 功能show profiles; 查看每个执行的 SQL 语句的 QUERY IDshow profile for query id; 查看该语句执行过程中每个状态的消耗时间show profile [all|cpu|block|io|context|switch|page faults]查看在某个资源所耗时间 Mysql 中使用索引的场景 匹配全值，即对索引中的列都指定具体值。 select * from table where col1=’xxx’ and col2=’xxx’;其中col1，col2都有索引 匹配值的范围查询，对索引的值进行范围查找。 select * from table where col&gt;=1 and col&lt;=100; 匹配最左前缀，仅仅使用索引中的最左边列进行查找，比如 col1+col2+col3 字段的联合索引能被包含 col1,(col1,col2),(col1,col2,col3)的等值查询利用，不能被 col2,col3,(col2,col3)的等值查询利用。 select from table where col1=’xxx’;select from table where col1=’xxx’ and col2=’xxx’;select * from table where col1=’xxx’ and col2=’xxx’ and col3=’xxx’; 仅仅对索引进行查询，当查询的列都在索引的字段中。 select col1,col2,col3 from table; 匹配列前缀，仅仅使用索引的第一列，并且只包含索引第一列的开头部分进行查找。 select * from table where col like ‘xxxx%’; 索引匹配部分精确，其它部分范围匹配。 select * from table where col1=’xxx’ and col2&gt;=1 and col2&lt;=100; 使用 col is null 条件会使用索引 select * from table where col is null; 存在索引但是不能使用索引的场景 以%开头的like查询不能利用 B-Tree 索引。 select * from table where col like ‘%xxx’; 数据类型出现隐式转换是不会使用索引，特别是列类型为字符串时，一定要用引号引起来。 select * from table where col=123; 其中col列类型为字符串 复合索引中，如果查询条件中不包含索引列的最左部分，不使用索引。 select * from table where col2=’xxx’ and col3=’xxx’; 如果 Mysql 估计使用索引比全表扫描更慢，则不使用索引。 用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面没有，同样不会使用索引。 select * from table where col1=’xxx’ or col2=’xxx’;其中 col1 有索引，而 col2 没有索引]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈TCP端口扫描技术]]></title>
      <url>%2F2017%2F05%2F04%2F%E6%B5%85%E8%B0%88TCP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[端口扫描描述在一般的网络攻击或者说渗透测试中，首要任务也是最重要的任务就是踩点，也就是对目标系统信息的收集，而端口扫描就是踩点中最重要的一项。端口扫描不仅用于踩点，并且经常用于批量抓取肉鸡，就是在扫描到端口开放后就用弱口令尝试登录系统，最后将这些肉鸡用于 ddos 等其它领域。互联网中常用的端口有 ftp 服务端口 21 ，ssh 服务端口 22 ，TELNET 远程登录服务 23 ，DNS 服务端口 53 ，http 服务端口 80，windous 远程桌面服务 3389 端口，SQL Server 服务端口 1433 ，mysql 端口 3306 。在网络中，你的系统开放了几个端口，也就意味着你为别人开了几扇门,所以网络攻击是离不开端口的，黑客利用这些开放的端口就能进入你的系统，所以一个系统开放越少的端口就越安全。我们在计算机网络课程中都学过，端口这个概念来自于OSI模型中的传输层，用于系统中各个应用程序与外界交流。而传输层有TCP和UDP协议，所以端口也就分为TCP端口和UDP端口，现在我着重讲解的是TCP端口扫描。 TCP 端口扫描技术TCP 端口扫描技术的基础是 TCP 协议中的三次握手以及四次挥手，这里面就涉及了 TCP 首头中的几个控制位，URG，ACK，PSH，RST，SYN，FIN。一次完整的 TCP 连接的步骤： 客户端发起连接将数据报中将 TCP 首头的 SYN 控制位置为 1，表明这是一个连接请求 。 服务端接受到连接请求，如果这个端口是开放的，就将回复的数据报 TCP 首头中 SYN 置为1，ACK 位也置位 1，表明接受请求并且也请求连接。如果这个端口没有开放，就将 RST 位置为1，表明这个连接失败。 客户端接受到服务器的回复，如果 SYN 和 ACK 位为1，就将 RST 位和 ACK 位置为 1 ，表明接受请求并且连接完毕。如果 RST 位为1，说明连接失败。 而每种 TCP 端口扫描技术都是在这上面动手脚。 TCP 全连接全 TCP 连接是 TCP 端口扫描的基础。它是我们最熟悉的，我们经常写的网络程序都会用到，它的原理很简单，就是一个普通的完整的 sockt 连接，也就是完整的三次握手和四次挥手。如果连接成功就说明这个端口是开放的，反之则是关闭的。虽然这种扫描技术简单且容易实现并且无需任何特殊权限，但是这种扫描容易被检测出来并且很慢，所以很不安全，用的很少。 SYN 扫描SYN 扫描也被称为半开放扫描，它和 TCP 全连接差不多，只是如果端口开放，在第三次握手的时候只将 RST 位置为 1 。直接就将连接断开了，这样就可以绕开很多防火墙，检测出来的几率大大减小，就安全很多并且比较准确，所以这种方式用的比较多。 FIN 扫描FIN 扫描是一种隐藏连接扫描，它和前两种有比较大的区别，因为前两种都是在建立连接是操作的，而这种扫描方式是基于断开连接的。它将 TCP 首头中 FIN 控制位置为 1 ，请求与服务器断开连接，如果服务器上这个端口关闭时，服务器会返回一个报文，并且 RST 位置为 1 。如果这个端口开放，因为并没有建立连接，何谈断开连接，所以服务器不会返回任何报文。而如果服务器返回一个 IMCP 报文，则表示这个报文被防火墙过滤了，所以这种方式很准确且速度比前两种快得多。 常见的端口扫描器 Nmap:Nmap 是一款用于网络发现和安全审计的网络安全工具，支持十几种端口扫描技术，当然它不仅用于端口扫描，它的功能很强大，基本是网络攻击的必备工具。 Zmap:Zmap 是一款号称一个小时扫完全网的端口扫描器，它采用的是一种加强的 SYN 扫描技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven将java项目打包成可独立运行的jar包]]></title>
      <url>%2F2017%2F04%2F04%2FMaven%E5%B0%86java%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E7%8B%AC%E7%AB%8B%E8%BF%90%E8%A1%8C%E7%9A%84jar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[在java项目中，常常需要打包成独立jar包方便发送或者发放。而maven默认的打包插件并没有在项目清单MANIFEST.MF中添加主类和依赖信息，所以运行时就会出错。所以我们需要使用其它的插件来打包。 方法一 使用maven-assembly-plugin插件123456789101112131415161718192021222324252627282930&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 方法二 使用maven-shade-plugin插件1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果使用了Spring，Spring Framework的多个jar包中包含相同的文件spring.handlers和spring.schemas，如果生成一个jar包会互相覆盖。为了避免互相影响，可以使用AppendingTransformer来对文件内容追加合并1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 引用 http://blog.csdn.net/daiyutage/article/details/53739452]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式学习（续）]]></title>
      <url>%2F2017%2F03%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BB%AD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[适配器模式 将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 外观模式 提供一个统一的接口用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts 2 复习]]></title>
      <url>%2F2017%2F03%2F21%2F2017-3-21-Struts-2-%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Struts 2 简介Apache Struts 2是一个用于开发Java EE网络应用程序的开源框架。它利用并延伸了Java Servlet API，鼓励开发者采用MVC架构。Struts 2 与Struts 1 有很大的不同，它缘起于Apache的WebWork框架，旨在提供相对于Struts1框架的增强和改进，同时保留与Struts1框架类似的结构。但实质是以WebWork为核心。2005年12月，WebWork宣布WebWork 2.2以Apache Struts 2的名义合并至Struts。 Struts 2 原理Struts 2 结构图: Struts 2 流程图: Struts 2 处理步骤: 客户端发生一个请求（HttpServletRequest）； 请求被Struts 2 中定义的三层过滤器（Filter）如：ActionCOntextCleanUp、SiteMesh、FilterDispatcher； FilterDisPatcher做为Struts 2 的控制器核心，询问ActionMapper是否需要调用某个Action来处理这个请求，如果决定调用,FilterDispatcher则把请求交给ActionProxy； ActionProxy通过Configuration Manager查询配置文件（struts.xml），找到需要调用的Action类。 ActionProxy 创建一个ActionInvocation 的实例，同时ActionInvocation 通过代理模式调用Action。但在调用之前会根据配置文件加载所有与Action 相关的Interceptor； 当Action 执行完毕后，ActionInvocation 负责根据配置文件找到相应的返回结果（struts.xml中action节点的result节点）并执行相关动作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式学习]]></title>
      <url>%2F2017%2F03%2F14%2F2017-3-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[OO基础 抽象 封装 多态 继承 OO原则 封装变化的 多用组合，少用继承 针对接口编程，不针对实现编程 低耦合，高内聚 对扩展开放，对修改关闭 OO模式模式是历经验证的OO设计经验 策略模式 策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。（例子：鸭子飞的行为与叫的行为） 观察者模式 观察者模式定义了对象之间的一对多依赖，当一个对象(主题)改变状态时，它的所有依赖者(观察者)都会收到通知并自动更新。(例子：报社与订阅者之间的关系） 装饰者模式 动态的将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。java库中IO类如FileInputStream(new InputStream())采用此模式。(例子：饮料添加各种调料） 工厂方法模式 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。(各个地方开披萨分店，但各个地方口味不同） 单例模式 单例模式就是一个类只能生成一个对象。分为懒汉式（用时生成对象）和饿汉式（类加载时就生成对象），懒汉式线程不安全，饿汉式线程安全。懒汉式可以将获得对象的静态方法变成同步方法（加synchronized关键字）使之成为线程安全。当然这种方式性能不太好，另一种方式是“双重检查加锁”，在判断对象是否生成后再同步。1234567if(instance == null)&#123; synchronized (Singleton.class) &#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python编码详解]]></title>
      <url>%2F2017%2F02%2F27%2F2017-2-27-python%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[概念编码（Encode） 用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。也就是将文字等信息以二进制数据存储到计算机中。与之相对应的就是解码（Decode）。 问题由在计算机中，经常会遇到乱码，莫名其妙就是一堆看不懂的东西。现在我主要要两个地方经常遇到乱码，一个是网站网页中，经常写的网页中文就是乱码，这个还好解决一点。第二个就是在python编程中，经常会遇到莫名错误提示，代表性的：&lt; UnicodeDecodeError:’ascii’ codec can’t decode byte 0xe5 in position 0有时候搞半天不知道哪儿出错了，就卡在那儿不知所措。要想解决这些问题，我们就必须把计算机中编码解码问题搞清楚。 编码历史#ASCII1946年2月14日第一台计算机在每个宾夕法尼亚大学诞生，为了在计算机中表示英语，美国人就制定了一套标准，这就是ASCII。它用一个字节来表示英文中所有字符和一些常用字符(键盘上每一个键位)，一个字节（8位）可以表示256个字符，表示英文中那几个字符绰绰有余。并且刚开始只用了7位，最高位保留为0。后来计算机普及到西欧地区时才将最高位用到，制定了EASCII（Extesible ASCII）标准。 #GB2312和GBK20世纪八十年代左右，计算机开始普及到中国，但这时就面临着一个问题，那就是汉字成千上万，这已经不是ASCII所能表示的范围了。为了解决这个问题，1981年中国国家标准总局发布了GB2312编码标准。它基本能表示99.75%的汉字。但随着各方面的需求，这也不能满足。于是又在GB2312的基础上又创建了GBK编码。它不仅能表示27484个汉字。还可以表示很多少数民族的文字。 #Unicode就这样，全世界各国都发布了自己的标准。在互联网上交流和传输数据就会出现问题。于是为了统一世界的文字编码。统一国际组织提出了Unicode编码。普遍所用的Unicode用4个字节来表示字符，最高位仍保留为0，这完全能囊括世界所有的文字字符，世界上任何一个字符都可以用一个Unicode编码来表示，一旦字符的Unicode编码确定下来后，就不会再改变了。 #UTF-8Unicode的实现方式不同于编码方式。在实际传输与保存时，由于不同的系统平台设计不一定，或者为了节省存储空间，必定用4个字节来保存一个字符太浪费空间了。于是Unicode就有了不同的实现方式，如UTF-16，UTF-8等，当然用的多的就是UTF-8了。 UTF-8（Unicode Transformation Format）作为Unicode的一种实现方式，广泛应用于互联网，它是一种变长的字符编码，可以根据具体情况用1-4个字节来表示一个字符。比如英文字符这些原本就可以用ASCII码表示的字符用UTF-8表示时就只需要一个字节的空间，和ASCII是一样的。对于多字节（n个字节）的字符，第一个字节的前n为都设为1，第n+1位设为0，后面字节的前两位都设为10。剩下的二进制位全部用该字符的unicode码填充。以汉字“好”为例，“好”对应的Unicode是597D，对应的区间是0000 0800–0000 FFFF，因此它用UTF-8表示时需要用3个字节来存储，597D用二进制表示是： 0101100101111101，填充到1110xxxx 10xxxxxx 10xxxxxx得到11100101 10100101 10111101，转换成16进制：e5a5bd，因此“好”的Unicode”597D”对应的UTF-8编码是”E5A5BD” #Python字符编码问题由于Python出的比Uncode早，所以python用的编码就是ASICC，源代码也必须是ASCII，所以在源码中不能有汉字，为了在源码中支持中文，就必须在在源文件开头指定编码格式。 #coding=utf-8或者-- coding: utf-8 __在python中字符串有两种数据类型str和unicode。str类型的字符具体编码和操作系统有关。 python中str与unicode之间的转换也是decode和encode： str–&gt;unicode 用decode方法。unicode–&gt;str 用encode方法。 #参考 https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;mid=2652564196&amp;idx=2&amp;sn=f12b49f57d22309fe84e6c2518e99de5&amp;pass_ticket=15P%2BhK91bYNpbTZ4iSMRdhysUWU%2BrOfaA0lJ5ydo4%2FfGVjyXErn4ZN70qKCqwPf%2B http://www.liaoxuefengcom/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始！]]></title>
      <url>%2F2017%2F02%2F08%2F2017-2-8-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%EF%BC%81%2F</url>
      <content type="text"><![CDATA[前期总结眨眼间，大三已去一半，回顾大学两年半,基本都在各种论坛闲逛，基本没怎么发言，都是潜水。 或者折腾各种软件，杂七杂八的东西。虽然也学到了不少东西，但是我总觉得缺少了很多东西，在实际操作中总是会遇到很多问题。特别是上学期，我严重发现了自己的不足。也有过一次短期培训，让我稍微清楚了实际项目的流程。 经过自己的总结，我得出以下一些问题。 学的太多太杂，不深入。 自己学得模式有点像猴子搬包谷，看到听到什么就想去学什么。 实际操作太少，基本就是看了一些文章。 自己也有点太过自(zi)信(da)，总认为已经够了。 后期展望大三上期就像一个过渡期，让我看到了以前得不足，让我明白了很多东西。也让我对未来有了一定得规划,准备。争取在大学接下来的日子尽量充实自己，找一个好的工作，在计算机这条道路上走的更远。 确定未来方向，主要专研java，python方面，当然这里面也包括了很多东西，尽量都深入一下。 多找一些实际项目来做，尽量多操作，多实践，弥补这方面的不足。 最后最后说一下本博客得开通吧！首先感谢一下hexo和github以及next，让我们写博客更方便，快捷，开源大法好。 由于一个新的开始嘛，我就想着现在开始写博客。一来提高自己得写作以及表达能力；二来总结一下自己所学的知识，所谓好记性不如烂笔头嘛；三来和各位分享一下自己的心得，当然能得到大家的评鉴就更好了，一起提高嘛！！。 开始起航吧,加油！！！！]]></content>
    </entry>

    
  
  
</search>
